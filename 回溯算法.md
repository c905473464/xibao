

### 回溯算法

#### 正规模板如下：

注意：

- 只有当不用继续搜索时才能return，如果要一直搜索下去，则不能有return

- 在拷贝path时，应当是深度拷贝
- 正规写法中全局共享一个 path，每次添加到 res 中，需要深度拷贝
- 由于是全局的 path，因此每次需要对 path 进行 push 和 pop 操作

```python
# 正规模板
res = []
path = []
def backtrack(未探索区域, res, path):
    if path 满足条件:
        res.add(path) # 深度拷贝
        # return  # 如果不用继续搜索需要 return
    for 选择 in 未探索区域当前可能的选择:
        if 当前选择符合要求:
            path.add(当前选择)
            backtrack(新的未探索区域, res, path)
            path.pop()   # 撤销选择
```

#### 简化模板如下

不同的路径使用的是不同的path，因此不需要撤销选择操作，赋值时也不需要深拷贝

```python
# 简化模板
res = []
path = []
def backtrack(未探索区域, res, path):
    if path 满足条件:
        res.add(path)  # 浅拷贝
        # return  # 如果不用继续搜索需要 return
    for 选择 in 未探索区域当前可能的选择:
        if 当前选择符合要求：
            backtrack(新的未探索区域, res, path+当前选择)
```

